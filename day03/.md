# 类型转化
## 1.自动类型提升
1. 当存储范围小的数据类型的变量与存储范围大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。
2. 当byte、short、char之间做运算时，会自动转为int型，包含同类型预算（byte+byte）
> 存储范围大小由小变大的提升

byte、short、char --> int --> long --> float --> double
+ 自动提升的问题
```java
  long l1 = 123123; // 不加L表示为右边是int类型，自动转化为l1，编译通过
  long l2 = 12323321321312321312312; // 编译不通过，因为右边的数值超过了int存储范围

  float f1 = 3.123; // 编译不通过，不加F表示为右边是double类型，自动转化不能double转float
```
+ 常量的问题
> 整数常量默认int类型；浮点数常量默认double类型
```java
  byte b1 = 11;
  byte result1 = b1 + 1; // 编辑不通过
  float f1 = 3.14; // 编辑不通过
  float f2 = 3.14F;
  float result2 = f2 + 1.2; // 编辑不通过
```
## 2.强制转化
使用(强转类型)，可能会损失精度
```java
  int i1 = (int)12.345;
```

# String类型
1. 引用数据类型
2. ""
3. 可以和8种基本数据类型做运算，运算只能是连接运算：+
4. Stirng不能和基本数据类型直接通过强制转化改变数据类型，要使用特定的API。eg：parseInt

# 运算符
> 当byte、short、char之间做运算时，会自动转为int型

> float 之间做运算，不会转为double
## 逻辑运算符
### n++ 和 ++n
+ n++为新赋值在运算，即使 result = (n++) 也是先赋值
+ ++n为先运算在赋值
```java
  int n = 10;
  int m = 10;
  int result1 = n+ (++n) + (++n); // 10 + 11 + 12
  System.out.println("result: " + result1 + " n: " + n);
  int result2 = m+ (++m) + (m++); // 10 + 10 + 12
  System.out.println("result: " + result2 + " m: " + m);
```
### 逻辑与&和 短路与&&，逻辑或|和短路或||
+ &&为短路与，&&前面为false时，&&后代码不执行
+ ||为短路或，||前面为true时，||后代码不执行

## 位运算符
+ 左移 <<：数字转为二进制，往左移动
  1. 正数：移动后补0
  > 8 << 2 = 8*2**2 = 8*4 = 32
  2. 负数：符号补1，，其他补0
  > -8 << 2 = -8*2**2 = -8*4 = -32
+ 右移 \>>：数字转为二进制，往右移动；数字为正时全补0，为负全补1
  1. 正数：移动后补0
  > 8 >> 2 = 8/(2**2) = 8/4 = 2
  2. 负数：符号为补1，其他补0
  > -8 >> 2 = -8/(2**2) = -8/4 = -2
+ 无符号右移 \>>>：数字转为二进制，往右移动